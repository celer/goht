// Code generated by hamlet - DO NOT EDIT.

package main

import "bytes"
import "context"
import "io"
import "github.com/stackus/hamlet"

// Hamlet supports the Ruby 1.9 hash style of attributes. The other styles
// such as HTML style, or Ruby rocket style are not supported. This should
// not be a problem as the Ruby 1.9 style is very similar to the style used
// by Go for maps.

func StaticAttrs() hamlet.Template {
	return hamlet.TemplateFunc(func(ctx context.Context, __w io.Writer) (__err error) {
		__buf, __isBuf := __w.(*bytes.Buffer)
		if !__isBuf {
			__buf = hamlet.GetBuffer()
			defer hamlet.ReleaseBuffer(__buf)
		}
		var __children hamlet.Template
		ctx, __children = hamlet.PopChildren(ctx)
		_ = __children
		if _, __err = __buf.WriteString("<p class=\"foo\" id=\"bar\">This is a paragraph.</p>\n"); __err != nil {
			return
		}
		if !__isBuf {
			_, __err = __w.Write(hamlet.NukeWhitespace(__buf.Bytes()))
		}
		return
	})
}

// You can also use dynamic values for your attributes. Dynamic attribute
// values share the same syntax as the interpolated values. A hash and a
// pair of curly braces.

var myDynamicValue = "foo"

func DynamicAttrs() hamlet.Template {
	return hamlet.TemplateFunc(func(ctx context.Context, __w io.Writer) (__err error) {
		__buf, __isBuf := __w.(*bytes.Buffer)
		if !__isBuf {
			__buf = hamlet.GetBuffer()
			defer hamlet.ReleaseBuffer(__buf)
		}
		var __children hamlet.Template
		ctx, __children = hamlet.PopChildren(ctx)
		_ = __children
		if _, __err = __buf.WriteString("<p"); __err != nil {
			return
		}
		var __var1 string
		__var1, __err = hamlet.BuildClassList(myDynamicValue)
		if __err != nil {
			return
		}
		if _, __err = __buf.WriteString(" class=\"" + __var1 + "\""); __err != nil {
			return
		}
		if _, __err = __buf.WriteString(" id=\"bar\">This is a paragraph.</p>\n"); __err != nil {
			return
		}
		if !__isBuf {
			_, __err = __w.Write(hamlet.NukeWhitespace(__buf.Bytes()))
		}
		return
	})
}

// There are times when you have a lot of attributes and you want to keep
// your lines short. You can break up your attributes into multiple lines
// without any additional syntax.
// You may include a comma after the last attribute if you wish but it is
// not required.

func MultiLineAttrs() hamlet.Template {
	return hamlet.TemplateFunc(func(ctx context.Context, __w io.Writer) (__err error) {
		__buf, __isBuf := __w.(*bytes.Buffer)
		if !__isBuf {
			__buf = hamlet.GetBuffer()
			defer hamlet.ReleaseBuffer(__buf)
		}
		var __children hamlet.Template
		ctx, __children = hamlet.PopChildren(ctx)
		_ = __children
		if _, __err = __buf.WriteString("<p"); __err != nil {
			return
		}
		var __var1 string
		__var1, __err = hamlet.BuildClassList(myDynamicValue)
		if __err != nil {
			return
		}
		if _, __err = __buf.WriteString(" class=\"" + __var1 + "\""); __err != nil {
			return
		}
		if _, __err = __buf.WriteString(" id=\"bar\">This is a paragraph.</p>\n"); __err != nil {
			return
		}
		if !__isBuf {
			_, __err = __w.Write(hamlet.NukeWhitespace(__buf.Bytes()))
		}
		return
	})
}

// You may include as much whitespace as you wish between the attribute,
// operator, value, and attribute separator. The following are all valid.

func WhitespaceAttrs() hamlet.Template {
	return hamlet.TemplateFunc(func(ctx context.Context, __w io.Writer) (__err error) {
		__buf, __isBuf := __w.(*bytes.Buffer)
		if !__isBuf {
			__buf = hamlet.GetBuffer()
			defer hamlet.ReleaseBuffer(__buf)
		}
		var __children hamlet.Template
		ctx, __children = hamlet.PopChildren(ctx)
		_ = __children
		if _, __err = __buf.WriteString("<p"); __err != nil {
			return
		}
		var __var1 string
		__var1, __err = hamlet.BuildClassList(myDynamicValue)
		if __err != nil {
			return
		}
		if _, __err = __buf.WriteString(" class=\"" + __var1 + "\""); __err != nil {
			return
		}
		if _, __err = __buf.WriteString(" id=\"bar\">This is a paragraph.</p>\n<p"); __err != nil {
			return
		}
		var __var2 string
		__var2, __err = hamlet.BuildClassList(myDynamicValue)
		if __err != nil {
			return
		}
		if _, __err = __buf.WriteString(" class=\"" + __var2 + "\""); __err != nil {
			return
		}
		if _, __err = __buf.WriteString(" id=\"bar\">This is a paragraph.</p>\n<p"); __err != nil {
			return
		}
		var __var3 string
		__var3, __err = hamlet.BuildClassList(myDynamicValue)
		if __err != nil {
			return
		}
		if _, __err = __buf.WriteString(" class=\"" + __var3 + "\""); __err != nil {
			return
		}
		if _, __err = __buf.WriteString(" id=\"bar\">This is a paragraph.</p>\n<p"); __err != nil {
			return
		}
		var __var4 string
		__var4, __err = hamlet.BuildClassList(myDynamicValue)
		if __err != nil {
			return
		}
		if _, __err = __buf.WriteString(" class=\"" + __var4 + "\""); __err != nil {
			return
		}
		if _, __err = __buf.WriteString(" id=\"bar\">This is a paragraph.</p>\n"); __err != nil {
			return
		}
		if !__isBuf {
			_, __err = __w.Write(hamlet.NukeWhitespace(__buf.Bytes()))
		}
		return
	})
}

// The dynamic attribute values may also include formatting rules just like
// the interpolated values. The attribute values are always evaluated as
// strings and are always rendered inside double quotes in the final HTML.

var intVar = 10

func FormattedValue() hamlet.Template {
	return hamlet.TemplateFunc(func(ctx context.Context, __w io.Writer) (__err error) {
		__buf, __isBuf := __w.(*bytes.Buffer)
		if !__isBuf {
			__buf = hamlet.GetBuffer()
			defer hamlet.ReleaseBuffer(__buf)
		}
		var __children hamlet.Template
		ctx, __children = hamlet.PopChildren(ctx)
		_ = __children
		if _, __err = __buf.WriteString("<textarea rows=\""); __err != nil {
			return
		}
		if _, __err = __buf.WriteString(hamlet.EscapeString(hamlet.FormatString("%d", intVar)) + "\""); __err != nil {
			return
		}
		if _, __err = __buf.WriteString(" cols=\"80\">\n</textarea>\n"); __err != nil {
			return
		}
		if !__isBuf {
			_, __err = __w.Write(hamlet.NukeWhitespace(__buf.Bytes()))
		}
		return
	})
}
