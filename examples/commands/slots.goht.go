// Code generated by GoHT v0.8.1 - DO NOT EDIT.
// https://github.com/stackus/goht

package commands

import "context"
import "io"
import "github.com/stackus/goht"

// GoHT templates can be built with a slot based architecture.
// This allows for a more modular approach to building templates.
//
// Any Template can be used as slotted content.
//
// The following two "Name" templates can be rendered like normal in the
// application code with something like:
//
// err := AdminName("SuperAdminUser").Render(ctx, w)

func Name(userName string) goht.Template {
	return goht.TemplateFunc(func(ctx context.Context, __w io.Writer, __sts ...goht.SlottedTemplate) (__err error) {
		__buf, __isBuf := __w.(goht.Buffer)
		if !__isBuf {
			__buf = goht.GetBuffer()
			defer goht.ReleaseBuffer(__buf)
		}
		var __children goht.Template
		ctx, __children = goht.PopChildren(ctx)
		_ = __children
		if _, __err = __buf.WriteString("<div class=\"user\">\n<span>"); __err != nil {
			return
		}
		var __var1 string
		if __var1, __err = goht.CaptureErrors(goht.EscapeString(userName)); __err != nil {
			return
		}
		if _, __err = __buf.WriteString(__var1); __err != nil {
			return
		}
		if _, __err = __buf.WriteString("</span>\n</div>\n"); __err != nil {
			return
		}
		if !__isBuf {
			_, __err = __w.Write(__buf.Bytes())
		}
		return
	})
}

func AdminName(adminName string) goht.Template {
	return goht.TemplateFunc(func(ctx context.Context, __w io.Writer, __sts ...goht.SlottedTemplate) (__err error) {
		__buf, __isBuf := __w.(goht.Buffer)
		if !__isBuf {
			__buf = goht.GetBuffer()
			defer goht.ReleaseBuffer(__buf)
		}
		var __children goht.Template
		ctx, __children = goht.PopChildren(ctx)
		_ = __children
		if _, __err = __buf.WriteString("<div class=\"admin\">\n<span>"); __err != nil {
			return
		}
		var __var1 string
		if __var1, __err = goht.CaptureErrors(goht.EscapeString(adminName)); __err != nil {
			return
		}
		if _, __err = __buf.WriteString(__var1); __err != nil {
			return
		}
		if _, __err = __buf.WriteString("</span>\n</div>\n"); __err != nil {
			return
		}
		if !__isBuf {
			_, __err = __w.Write(__buf.Bytes())
		}
		return
	})
}

// In your application code, you can also slot in either of the two "Name"
// templates by passing in the template as an optional third argument to
// the `Render` call for the main "parent" template.
//
// err := SlotTemplate().Render(ctx, w,
// 	AdminName("SuperAdminUser").Slot("name"),
// )
//
// All we did was swap out a call to `Render()` with a call to `Slot()` to
// reuse an existing template as a slotted template. We need to pass in the
// name of the slot we want to use, which in this case is "name".
//
// The following SlotTemplate has no idea what content will ultimately be
// passed in. If it receives a Template for its `name` slot, it will render the
// templates content into that slot.

// Slots can also have default content. A slot that does not receive any content
// will not be rendered in the final output. However, if we provide default content
// then we can have a fallback to use if no content is passed in.

func SlotTemplate() goht.Template {
	return goht.TemplateFunc(func(ctx context.Context, __w io.Writer, __sts ...goht.SlottedTemplate) (__err error) {
		__buf, __isBuf := __w.(goht.Buffer)
		if !__isBuf {
			__buf = goht.GetBuffer()
			defer goht.ReleaseBuffer(__buf)
		}
		var __children goht.Template
		ctx, __children = goht.PopChildren(ctx)
		_ = __children
		if _, __err = __buf.WriteString("<div class=\"name-content\">"); __err != nil {
			return
		}
		if __st := goht.GetSlottedTemplate(__sts, "name"); __st != nil {
			if __err = __st.Render(ctx, __buf, __st.SlottedTemplates()...); __err != nil {
				return
			}
		}
		if _, __err = __buf.WriteString("</div><div class=\"actions\">"); __err != nil {
			return
		}
		if __st := goht.GetSlottedTemplate(__sts, "actions"); __st != nil {
			if __err = __st.Render(ctx, __buf, __st.SlottedTemplates()...); __err != nil {
				return
			}
		} else {
			if _, __err = __buf.WriteString("No available actions."); __err != nil {
				return
			}
		}
		if _, __err = __buf.WriteString("</div>\n"); __err != nil {
			return
		}
		if !__isBuf {
			_, __err = __w.Write(__buf.Bytes())
		}
		return
	})
}

func SlotWithDefaultTemplate() goht.Template {
	return goht.TemplateFunc(func(ctx context.Context, __w io.Writer, __sts ...goht.SlottedTemplate) (__err error) {
		__buf, __isBuf := __w.(goht.Buffer)
		if !__isBuf {
			__buf = goht.GetBuffer()
			defer goht.ReleaseBuffer(__buf)
		}
		var __children goht.Template
		ctx, __children = goht.PopChildren(ctx)
		_ = __children
		if _, __err = __buf.WriteString("<div class=\"name-content\">\n\t"); __err != nil {
			return
		}
		if __st := goht.GetSlottedTemplate(__sts, "name"); __st != nil {
			if __err = __st.Render(ctx, __buf, __st.SlottedTemplates()...); __err != nil {
				return
			}
		} else {
			if _, __err = __buf.WriteString("<span>No user name has been set.</span>"); __err != nil {
				return
			}
		}
		if _, __err = __buf.WriteString("</div>\n<div class=\"actions\">\n\t"); __err != nil {
			return
		}
		if __st := goht.GetSlottedTemplate(__sts, "actions"); __st != nil {
			if __err = __st.Render(ctx, __buf, __st.SlottedTemplates()...); __err != nil {
				return
			}
		} else {
			if _, __err = __buf.WriteString("<span>No actions have been set.</span>"); __err != nil {
				return
			}
		}
		if _, __err = __buf.WriteString("</div>\n"); __err != nil {
			return
		}
		if !__isBuf {
			_, __err = __w.Write(__buf.Bytes())
		}
		return
	})
}

// When you pass in a template to a slot, that template can also have its own
// slots. This is done by adding one templates to the optional second parameter
// to the `Slot` method.
//
// err := Layout(layoutProps).Render(ctx, w,
//   Sidebar(sidebarProps).Slot("sidebar"),
//   Header(headerProps).Slot("header"),
//   UserDetailsPage(userProps).Slot("main",
//     LastActionResults(resultsProps).Slot("notifications"),
//   ),
//   Footer(footerProps).Slot("footer"),
// )

//
// The above example shows how you can pass in a template to a slot, and that
// template can also have its own slots.
