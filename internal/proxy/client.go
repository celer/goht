package proxy

import (
	"context"
	"fmt"
	"strings"

	"github.com/rs/zerolog"

	"github.com/stackus/goht/compiler"
	"github.com/stackus/goht/internal/protocol"
)

type Client struct {
	protocol.Client
	smc    *SourceMapCache
	dc     *DiagnosticsCache
	logger zerolog.Logger
}

var _ protocol.Client = (*Client)(nil)

func NewClient(c protocol.Client, smc *SourceMapCache, dc *DiagnosticsCache, logger zerolog.Logger) *Client {
	return &Client{
		Client: c,
		smc:    smc,
		dc:     dc,
		logger: logger,
	}
}

func (c *Client) PublishDiagnostics(ctx context.Context, params *protocol.PublishDiagnosticsParams) error {
	logger := c.logger.With().
		Str("uri", string(params.URI)).
		Int("count", len(params.Diagnostics)).
		Logger()

	logger.Debug().Msg("SERVER -> CLIENT: PublishDiagnostics")

	_, gohtURI := toGohtURI(params.URI)
	sm, ok := c.smc.Get(string(gohtURI))
	if !ok {
		c.logger.Warn().Msgf("unable to complete because the sourcemap for %q doesn't exist in the cache, has the didOpen notification been sent yet", gohtURI)
		return fmt.Errorf("unable to complete because the sourcemap for %q doesn't exist in the cache, has the didOpen notification been sent yet", gohtURI)
	}

	// update the uri to the original
	params.URI = gohtURI
	for i, diagnostic := range params.Diagnostics {
		var start, end compiler.Position
		start, ok = sm.SourcePositionFromTarget(int(diagnostic.Range.Start.Line), int(diagnostic.Range.Start.Character))
		if !ok {
			logger.Warn().Any("diagnostic", diagnostic).Msg("unable to map start position")
			continue
		}

		if diagnostic.Range.Start.Line == diagnostic.Range.End.Line {
			length := diagnostic.Range.End.Character - diagnostic.Range.Start.Character
			diagnostic.Range.Start.Line = uint32(start.Line)
			diagnostic.Range.Start.Character = uint32(start.Col)
			diagnostic.Range.End.Line = uint32(start.Line)
			diagnostic.Range.End.Character = uint32(start.Col) + length
			params.Diagnostics[i] = diagnostic
			continue
		}

		end, ok = sm.SourcePositionFromTarget(int(diagnostic.Range.End.Line), int(diagnostic.Range.End.Character))
		if !ok {
			logger.Warn().Any("diagnostic", diagnostic).Msg("unable to map end position")
			continue
		}

		diagnostic.Range.Start.Line = uint32(start.Line)
		diagnostic.Range.Start.Character = uint32(start.Col)
		diagnostic.Range.End.Line = uint32(end.Line)
		diagnostic.Range.End.Character = uint32(end.Col)
		params.Diagnostics[i] = diagnostic
	}
	params.Diagnostics = c.dc.WithGohtDiagnostics(string(gohtURI), params.Diagnostics)
	return c.Client.PublishDiagnostics(ctx, params)
}

const doNotEditMessage = "Do not edit this file!"

func (c *Client) ShowMessage(ctx context.Context, params *protocol.ShowMessageParams) error {
	c.logger.Info().Str("message", params.Message).Msg("SERVER -> CLIENT: ShowMessage")
	// Why is this message ignored?
	// Because gopls will return a message to the client to not edit the file when it contains
	// a header with "DO NOT EDIT". We include such a header in our generated Go files because
	// 1. they are generated, and 2. we include them in the files gopls sees because that causes
	// gopls to not do certain things like checking the position of the cursor in the file. This
	// particular check is a problem because it causes gopls to throw "column is beyond end of line"
	// errors for just about any interaction the user has with their IDE.
	if strings.HasPrefix(params.Message, doNotEditMessage) {
		return nil
	}
	return c.Client.ShowMessage(ctx, params)
}
